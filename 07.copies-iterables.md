7장: 객체 복사, 순회 연산자와 함수
===

Copying Objects and Iterating Operations  

***
**박 진 수** 교수    
Intelligent Data Semantics Lab  
Seoul National University
***

<h3>Table of Contents<span class="tocSkip"></span></h3>
<div class="toc"><ul class="toc-item"><li><span><a href="#객체-참조와-항등-연산자" data-toc-modified-id="객체-참조와-항등-연산자-1">객체 참조와 항등 연산자</a></span></li><li><span><a href="#객체-복사" data-toc-modified-id="객체-복사-2">객체 복사</a></span><ul class="toc-item"><li><span><a href="#할당(객체참조)" data-toc-modified-id="할당(객체참조)-2.1">할당(객체참조)</a></span><ul class="toc-item"><li><span><a href="#따라해보기" data-toc-modified-id="따라해보기-2.1.1">따라해보기</a></span></li></ul></li><li><span><a href="#얕은-복사" data-toc-modified-id="얕은-복사-2.2">얕은 복사</a></span><ul class="toc-item"><li><span><a href="#따라해보기" data-toc-modified-id="따라해보기-2.2.1">따라해보기</a></span><ul class="toc-item"><li><span><a href="#분할-[:]" data-toc-modified-id="분할-[:]-2.2.1.1">분할 [:]</a></span></li><li><span><a href="#가변-복합자료형-copy()-메소드" data-toc-modified-id="가변-복합자료형-copy()-메소드-2.2.1.2">가변 복합자료형 copy() 메소드</a></span></li><li><span><a href="#가변-복합자료형-생성자" data-toc-modified-id="가변-복합자료형-생성자-2.2.1.3">가변 복합자료형 생성자</a></span></li><li><span><a href="#copy-모듈의-copy()-함수" data-toc-modified-id="copy-모듈의-copy()-함수-2.2.1.4">copy 모듈의 copy() 함수</a></span></li></ul></li><li><span><a href="#중첩-가변자료형의-얕은-복사" data-toc-modified-id="중첩-가변자료형의-얕은-복사-2.2.2">중첩 가변자료형의 얕은 복사</a></span><ul class="toc-item"><li><span><a href="#따라해보기" data-toc-modified-id="따라해보기-2.2.2.1">따라해보기</a></span></li></ul></li></ul></li><li><span><a href="#깊은-복사" data-toc-modified-id="깊은-복사-2.3">깊은 복사</a></span><ul class="toc-item"><li><span><a href="#따라해보기" data-toc-modified-id="따라해보기-2.3.1">따라해보기</a></span></li></ul></li></ul></li><li><span><a href="#순회형-연산자와-함수" data-toc-modified-id="순회형-연산자와-함수-3">순회형 연산자와 함수</a></span><ul class="toc-item"><li><span><a href="#순회형-연산자" data-toc-modified-id="순회형-연산자-3.1">순회형 연산자</a></span></li><li><span><a href="#순회형-함수" data-toc-modified-id="순회형-함수-3.2">순회형 함수</a></span><ul class="toc-item"><li><span><a href="#따라해보기" data-toc-modified-id="따라해보기-3.2.1">따라해보기</a></span><ul class="toc-item"><li><span><a href="#질의-함수" data-toc-modified-id="질의-함수-3.2.1.1">질의 함수</a></span></li><li><span><a href="#연산-함수" data-toc-modified-id="연산-함수-3.2.1.2">연산 함수</a></span></li></ul></li><li><span><a href="#정렬-함수" data-toc-modified-id="정렬-함수-3.2.2">정렬 함수</a></span></li><li><span><a href="#순환문과-함께-사용하는-유용한-함수" data-toc-modified-id="순환문과-함께-사용하는-유용한-함수-3.2.3">순환문과 함께 사용하는 유용한 함수</a></span></li></ul></li></ul></li></ul></div>

# 객체 참조와 항등 연산자

**객체 참조**란?

- 객체를 쉽게 불러오기 위해 컴퓨터 메모리 어딘가에 있는 개별 객체의 위치를 참조하는 것이다.

주로 **변수**를 통해 객체 참조를 한다.

***객체 참조의 값이 다르다는 것은 어떤 의미인가?***

두 객체의 객체 참조 값이 다르면 객체가 서로 다른 메모리 공간에 있기 때문에 비록 같은 값이어도 다른 객체다. 

이는 마치 사람의 이름이 같아도 서로 다른 주소에 산다면 다른 사람인 것에 비유할 수 있다.

다음 예는 객체의 값이 같은 경우지만 객체 참조가 다른 것을 보여 준다.


```python
x = 'stay hungry, stay foolish'
y = 'stay hungry, stay foolish'
print(x)
print(y)
```

먼저, 두 문자열의 값이 같은지 확인해보자.


```python
# 둘의 값이 같은가?
x == y                              
```

이처럼 두 객체의 값이 같은지 확인하는 연산자로는 **==**(같다)가 있다.

***그렇다면 이 두 문자열이 서로 같은 객체를 참조하는지 확인하는 방법은 없을까?***

있다.

항등 연산자를 사용하면 된다.

**항등 연산자**(identity operator)란?

- 왼쪽에 있는 변수와 오른쪽에 있는 변수가 같은 객체를 참조하는지 확인할 때 사용하는 연산자다.

사용하는 방법은 다음과 같다.

**`x is y`**

*x*와 *y*가 같은 객체를 참조하면(즉, 같은 메모리 공간에 있으면) '참(True)' 을 반환하고, 아니면 '거짓(False)'을 반환한다.


```python
# --- x = 'stay hungry, stay foolish'
# --- y = 'stay hungry, stay foolish'
# 둘은 같은 객체를 참조하고 있는가?
x is y                              
```

이번에는 새로운 변수 *z*에 *x*를 할당해보자.


```python
# --- x = 'stay hungry, stay foolish'
# z에 x를 할당한다.
z = x  
print(z)
```


```python
# --- y = 'stay hungry, stay foolish'
# --- z = 'stay hungry, stay foolish'
# z와 y의 값은 같은가?
z == y                              
```


```python
# z와 y는 같은 객체를 참조하고 있는가?
z is y                              
```


```python
# --- x = 'stay hungry, stay foolish'
# --- z = 'stay hungry, stay foolish'
# z와 x는 같은 객체를 참조하고 있는가?
z is x                              
```

# 객체 복사

객체를 복사하는 방법으로는 세가지가 있다.
1. 할당(객체참조)
1. 얕은 복사(shallow copy)
1. 깊은 복사(deep copy)

## 할당(객체참조)

객체를 복사하는 가장 간단한 방법은 할당 연산자 **=** 를 사용하는 것이다. 

할당 연산자는 실제로 해당 객체 자체를 '복사'하는 것이 아니라, 해당 객체에 대한 **객체 참조를 복사**한다.

객체를 할당하면 객체 참조만 복사하기 때문에 사실상 두 변수는 같은 객체를 참조한다. 

문제는 **가변자료형**이다. 

가변자료형은 값을 변경할 수 있기 때문에, 한쪽의 값을 변경하면 다른 쪽도 변경한 값을 참조하게 된다. 

### 따라해보기


```python
x = [1, 2, 3]  # 가변자료형 리스트를 x에 할당한다.
y = [1, 2, 3]  # 같은 값을 가진 또 다른 리스트를 y에 할당한다.
print(x)
print(y)
```


```python
x is y
```


```python
z = x          # x를 z에 할당한다.
print(z)
```


```python
# --- x, y, z = [1, 2, 3]
z.append('a')  # z에 'a'를 추가한다.
print(z)
print(x)
print(y)
```


```python
z is x          # z와 x는 같은 객체를 참조하는가?
```


```python
z is y          # z와 y는 같은 객체를 참조하는가?
```

## 얕은 복사

**얕은 복사**(shallow copy)란?

- 원본 객체가 가지고 있는 모든 객체의 객체참조를 복사해서 원본 객체와는 별도로 새로운 복사본(객체)를 만들어 반환한다.

원본 객체와 별도로 개별 복사본을 생성하지만, 원본과 복사본 둘 다 같은 객체참조를 하고 있다.

얕은 복사를 하는 방법은 크게 네 가지로 나누어 볼 수 있다.

1. 분할 연산자 **[:]** 로 전체를 추출하면 원본 객체와 별도로 개별 복사본을 생성할 수 있다. 
    - 단, 시퀀스형에서만 사용할 수 있다. 


2. 리스트, 딕셔너리, 세트의 **copy()** 메소드

1. 생성자 **list**(***순회형***), **dict**(***순회형***), **set**(***순회형***)

1. copy 모듈의 **copy()** 함수

### 따라해보기

#### 분할 [:]


```python
x = [1, 2, 3]
y = x          # 할당(객체 참조)한다.
```


```python
y is x         # y는 x와 같은 객체를 참조하고 있다.
```


```python
# --- x, y = [1, 2, 3]
x[-1] = 'a'    # x의 마지막 객체를 'a'으로 교체한다.
print(x)
print(y)
```


```python
# --- x = [1, 2, 'a']
z = x[:]       # 분할 연산자[:]로 얕은 복사를 한다.
```


```python
z is x         # z는 x와 다른 객체를 참조하고 있다.
print(z)
print(x)
```


```python
# --- z = [1, 2, 'a']
z[0] = 'b'     # z의 첫 번째 객체를 'b'로 교체한다.
print(z)
print(x)
print(y)
```

#### 가변 복합자료형 copy() 메소드 


```python
x = [1, 2, 3]
y = x          # 할당(객체참조)한다.
```


```python
y is x         # y는 x와 같은 객체를 참조하고 있다.   
```


```python
# --- x, y = [1, 2, 3]
x[-1] = 'a'    # x의 마지막 객체를 'a'으로 교체한다.
print(x)
print(y)
```


```python
# --- x = [1, 2, 'a']
z = x.copy()   # copy() 메소드로 얕은 복사를 한다.
```


```python
z is x         # z는 x와 다른 객체를 참조하고 있다.
print(z)
print(x)
```


```python
# --- z = [1, 2, 'a']
z[0] = 'b'     # z의 첫 번째 객체를 'b'로 교체한다.
print(z)
print(x)
print(y)
```

#### 가변 복합자료형 생성자


```python
x = [1, 2, 3]
y = x          # 할당(객체참조)한다.
```


```python
y is x         # y는 x와 같은 객체를 참조하고 있다.            
```


```python
# --- x, y = [1, 2, 3]
x[-1] = 'a'    # x의 마지막 객체를 'a'으로 교체한다.
print(x)
print(y)
```


```python
# --- x, y = [1, 2, 3]
z = list(x)    # 리스트 생성자로 얕은 복사를 한다.
```


```python
z is x         # z는 x와 다른 객체를 참조하고 있다.
print(z)
print(x)
```


```python
# --- z = [1, 2, 'a']
z[0] = 'b'     # z의 첫 번째 객체를 'b'로 교체한다.
print(z)
print(x)
print(y)
```

#### copy 모듈의 copy() 함수


```python
x = [1, 2, 3]
y = x             # 할당(객체참조)한다.
```


```python
y is x            # y는 x와 같은 객체를 참조하고 있다.            
```


```python
# --- x, y = [1, 2, 3]
x[-1] = 'a'       # x의 마지막 객체를 'a'으로 교체한다.
print(x)
print(y) 
```


```python
# --- x = [1, 2, 'a']
import copy       # copy 모듈을 불러온다.
z = copy.copy(x)  # copy 모듈의 copy() 함수로 얕은 복사를 한다.
```


```python
z is x            # z는 x와 다른 객체를 참조하고 있다.
print(z)
print(x)
```


```python
# --- z = [1, 2, 'a']
z[0] = 'b'        # z의 첫 번째 객체를 'b'로 교체한다.
print(z)
print(x)
print(y)
```

### 중첩 가변자료형의 얕은 복사

**문제점**  

얕은 복사의 경우 
- 원본과 복사본 둘 다 같은 객체를 참조를 하고 있기 때문에 
- 가변자료형이 또 다른 가변자료형을 가지고 있는 중첩 복합자료형의 경우
- 원본과 복사본 둘 중 하나의 값이 바뀌면 나머지도 영향을 받는다.

**[참고]**  

중첩(nested) 복합자료형
- 복합자료형이 또 다른 복합자료형을 객체로 가지고 있는 자료 구조를 말한다.

#### 따라해보기


```python
x = [1, 2, ['x', 'y', 'z']]  
y = x[:]                # 얕은 복사를 한다.
```


```python
x == y                  # 둘의 값이 같은지 확인한다.
```


```python
x is y                  # 둘이 같은 객체를 참조하는지 확인한다.
```


```python
x[0] is y[0]            # x와 y의 첫 번째 객체 참조가 같은지 확인한다.
```

`x[0]`과 `y[0]`는 같은 객체를 참조하고 있다.


```python
# --- x, y = [1, 2, ['x', 'y', 'z']]
x[0] = 'a'              # x의 첫 번째 객체를 1에서 'a'으로 바꾼다.
print(x)
print(y)
```

***x[0]과 y[0]는 분명히 같은 객체를 참조했는데 왜 둘의 값이 달라졌을까?***

다시 한번 둘의 객체 참조를 확인해보자.


```python
x[0] is y[0]            # x와 y의 첫 번쨰 객체 참조가 같은지 확인한다. => 다르다.
```

다시 확인해보니, 이제 `x[0]`와 `y[0]`는 서로 다른 객체를 참조하고 있다.

***그 이유는 무엇일까?***

가변 복합자료형라도 참조하는 객체가 불변자료형이면, 얕은 복사를 했을 때 원본이나 복사본 값이 바뀌어도 서로 영향을 미치지 않고 사용할 수 있다. 

비록 원본과 복사본 모두 같은 객체를 참조하지만, 참조하는 객체가 불변자료형이기 때문에 원본 객체와 별도의 객체(복사본)는 각각 서로에 영향을 주지 않으면서 변경할 수 있다.

즉, 새로운 객체를 생성한 후 이 객체의 주소를 참조하게 된다.

앞의 예에서 `x[0]`의 값인 1을 'a'로 바꿨는데 1은 불변자료형이라 1 자체를 바꿀 수 없다.

따라서, 메모리 어딘가에 'a'를 생성한 후 이 'a'의 위치를 새로 참조했기 때문에 `y[0]`의 값은 그대로이다.

문제는 복합자료형 안에 가변자료형이 있는 중첩 복합자료형일 때다. 

이 경우에 대해 알아보도록 하자.


```python
# --- x = ['a', 2, ['x', 'y', 'z']]
# --- y = [1, 2, ['x', 'y', 'z']]
x[-1] is y[-1]          # x와 y의 마지막 객체 참조가 같은지 확인한다.
```

얕은 복사를 했기 때문에 `x[-1]`과 `y[-1]`는 같은 객체를 참조하고 있다.


```python
y[-1][-1] = 'b'         # y의 마지막 객체를 'z'에서 'b'로 바꾼다.
print(y)
print(x)
```

이번에는 `x[-1][-1]`와 `y[-1][-1]`의 값이 둘 다 바뀌었다.

***그 이유는 무엇일까?***

얕은 복사를 하면 객체 참조만 복사를 하기 때문이다.

즉 둘 다 다음과 같이 서로 같은 객체를 참조한다.


```python
x[-1][-1] is y[-1][-1]  # x와 y 마지막 객체의 마지막 객체 참조가 같은지 확인한다.
```

앞의 예에서 알 수 있듯이

리스트 안에 또 다른 가변자료형(리스트, 딕셔너리, 세트)이 있다면,  

얕은 복사를 할 때 리스트에 있는 객체의 객체 참조(메모리 위치)만 복사하기 때문에, 복사본 역시 원본 리스트와 같은 객체를 참조한다. 

따라서 이 중 하나가 수정되면 나머지에서도 수정한 내용이 반영된다.

## 깊은 복사

**깊은 복사**(deep copy)란?

- 원본 객체에 있는 모든 가변자료형 **객체 자체를 별도로 복사**해서 다른 메모리 위치에 할당한 후, 복사한 객체들의 새 메모리 위치를 복사본의 변수에 할당한다. 

**깊은 복사**는 얕은 복사처럼 원본의 객체 참조를 복사하는 것이 아니라 새로 만든 복사본의 객체 위치를 참조한다. 

따라서 얕은 복사와는 다른 결과를 가져온다. 

**얕은 복사**는 같은 객체를 참조하지만, **깊은 복사**는 값은 같지만 원본과는 완전히 서로 다른 객체(복사본)를 참조한다.

### 따라해보기


```python
x = [1, 2, ['x', 'y', 'z']]
import copy
y = copy.deepcopy(x)    # 깊은 복사를 한다.
```


```python
x == y                  # 둘의 값이 같은지 확인한다.
```


```python
x is y                  # 둘이 같은 객체를 참조하는지 확인한다.
```


```python
x[0] is y[0]            # x와 y의 첫 번쨰 객체 참조가 같은지 확인한다.
```

`x[0]`와 `y[0]`는 같은 객체를 참조하고 있다.

***깊은 복사를 했는데도 왜 같은 객체를 참조하고 있을까?***

불변자료형은 값을 바꿀 수 없기 때문에 같은 객체를 참조해도 된다. 

따라서, 비록 깊은 복사를 하더라도 같은 객체를 참조한다.


```python
x[0] = 'a'              # x의 첫 번째 객체를 1에서 'a'으로 바꾼다.
```


```python
print(x)
```


```python
print(y)
```

다시 한번 둘의 객체 참조를 확인해보자.


```python
x[0] is y[0]            # x와 y의 첫 번째 객체 참조가 같은지 확인한다.
```

다시 확인해보니, 이제 `x[0]`와 `y[0]`는 서로 다른 객체를 참조하고 있다.


```python
# --- x = ['a', 2, ['x', 'y', 'z']]
# --- y = [1, 2, ['x', 'y', 'z']]
x[-1] is y[-1]          # x와 y의 마지막 객체 참조가 같은지 확인한다.
```

깊은 복사를 했기 때문에 `x[-1]`과 `y[-1]`는 서로 다른 객체를 참조하고 있다.

즉, 깊은 복사를 하면 **불변자료형**은 얖은 복사를 해서 객체 참조가 같지만, **가변자료형**이면 별도의 복사본을 만들기 때문에 얕은 복사와는 달리 객체 참조가 다르다.


```python
y[-1][-1] = 'b'         # y의 마지막 객체를 'z'에서 'b'로 바꾼다.
print(y)
print(x)
```

`y[-1][-1]`의 값을 'z'에서 'b'라 바꿔도 `x[-1][-1]`의 값은 영향을 받지 않는다.

그 이유는 다음과 같이  둘 다 서로 다른 객체를 참조하고 있기 때문이다.


```python
x[-1][-1] is y[-1][-1]  # x와 y 마지막 객체의 마지막 객체 참조가 같은지 확인한다.
```

***가변자료형을 얕은 복사한 후 하나의 값을 바꾸면 참조하는 나머지 값도 같이 바뀌는 문제가 있는데 왜 기본적으로 깊은 복사를 하지 않고 얕은 복사를 하는가?***

얕은 복사를 하면 참조되는 객체를 서로 공유하기 때문에 별도로 객체 자체를 따로 복사하는 것 보다 속도도 빠르고 메모리 공간도 적게 사용하기 때문에 깊은 복사보다 더 **효율적**이다.

# 순회형 연산자와 함수

## 순회형 연산자

결합 연산자 **+**
- ***s*** **+** ***t*** : 시퀀스형 ***s***와 ***t***를 합친 시퀀스형 자료를 반환한다.


```python
# 리스트와 리스트 더한 결과를 반환한다.
[1, 2, 3] + ['a', 'b', 'c']
```

반복 결합 연산자 __*__
- ***s*** __*__ ***n*** : 시퀀스형 ***s***를 ***n*** 횟수만큼 반복한 시퀀스형 자료를 반환한다.


```python
# 튜플을 5번 반복한 새로운 튜플을 반환한다.
(1, 2, 3) * 5
```

멤버십 연산자 **in**/**not in**
- ***x*** **in** ***i*** : 객체 ***x***가 순회형 ***i***에 있으면 참(**True**)을 반환한다. 
- **not in**은 객체 ***x***가 순회형 ***i***에 없으면 참(**True**)을 반환한다.


```python
'a' in {'a', 'b', 'c'}      # 집합 안에 'a'가 있는지 확인한다.
```


```python
'x' not in {'a', 'b', 'c'}  # 집합 안에 'x'가 없는지 확인한다.
```

## 순회형 함수

질의 함수 : **len()**, **all()**, **any()**  
연산 함수 : **min()**, **max()**, **sum()**  
정렬 함수 : **reversed()**, **sorted()**  
순환문과 함께 사용하는 유용한 함수 : **range()**, **enumerater()**, **zip()**

### 따라해보기

#### 질의 함수

**len**(***x***)
- ***x***의 길이를 반환한다.
- ***x***가 복합자료형이면 객체의 총 개수를 반환한다.
- ***x***가 문자열이면 문자의 개수를 반환한다.


```python
len([1, 2, 3])  # 리스트의 길이(즉, 담고 있는 객체의 수)를 반환한다.
```


```python
len('Python')   # 문자열의 길이(즉, 문자의 개수)를 반환한다.              
```

**all**(***i***) 
- 순회형 ***i***의 모든 객체가 '참'일 때만 참(**True**)을 반환한다.


```python
x = [7, -5, 8, 3, 9, 0]
```


```python
all(x)          
```

**0**이 거짓이라 **False**를 반환한다.

**any**(***i***) 
- 순회형 ***i*** 중 한 객체라도 '참'이면 참(True)을 반환한다.


```python
# --- [7, -5, 8, 3, 9, 0]
any(x)
```

앞에서 불린을 설명할 때 거짓'의 값은 **False**, **0**, **0.0**, **None**, 빈 문자열(**''**), 빈 복합자료형(**[]**, **()**, **{}**, **set()**)이라고 했는데 이를 `any()`나 `all()` 함수로 간단히 확인해볼 수 있다.


```python
# 불린형에서 False로 처리되는 것들이다.
any([False, 0, 0.0, None, '', [], (), set(), {}])   
```


```python
all([-15, 1.34, [1], (1,), set('a'), {None: 'NaN'}, ''])  
```

빈 문자열이 있다.

#### 연산 함수

`min()`과 `max()`는 순회형의 값 중 최솟값과 최댓값을 반환하는 함수다.

**min**(***i***, ***key***)

- 순회형 ***i***의 객체 중 가장 작은 값을 가진 객체를 반환한다.
- ***key*** 전달인자가 주어질 경우 전달인자 함수로 처리한 결괏값 중 가장 작은 값을 가진 객체를 반환한다.


```python
x = [7, -5, 8, 3, 9]
```


```python
max(x)  # x 중 최댓값을 찾아서 반환한다.
```

**max**(***i***, ***key***)

- 순회형 ***i***의 객체 중 가장 큰 값을 가진 객체를 반환한다.
- ***key*** 전달인자가 주어질 경우 전달인자 함수로 처리한 결괏값 중 가장 큰 값을 가진 객체를 반환한다.


```python
# --- x = [7, -5, 8, 3, 9]
min(x)  # x 중 최솟값을 찾아서 반환한다.                
```

`min()`과 `max()` 함수는 ***key***의 전달인자로 함수를 사용할 수 있다. 이때 함수 이름만 사용하며, 함수 뒤에 붙는 괄호는 생략한다.

다음 코드는 ***key***로 전달 하는 함수로 `abs()`를 사용한다.


```python
# --- x = [7, -5, 8, 3, 9]
min(x, key=abs)  # x의 절대 값 중에 최솟값을 찾아서 반환한다.
```

`min()`과 `max() 함수에 숫자가 아닌 문자도 올 수 있다.


```python
s = ['a', 'B', 'c', 'd', 'E']
max(s)  # s 중 최댓값을 찾아서 반환한다.                 
```

***왜 가장 큰 알파벳이 'E'가 아니라 'd'일까?***


```python
# --- s = ['a', 'B', 'c', 'd', 'E']
min(s)  # s 중 최솟값을 찾아서 반환한다.               
```

***왜 가장 작은 알파벳이 'a'가 아니라 'B'일까?***

유니코드 문자의 순서를 기준으로 최솟값과 최댓값을 찾기 때문이다. 알파벳은 대문자가 먼저 오고, 그 다음에 소문자가 온다. 


```python
ord('d')
ord('B')
```

`ord()`는 해당 유니코드 문자의 정숫값을 반환하는 함수다.

대소문자를 구분하지 않고 최댓값을 구하려면 다음처럼 문자열 클래스의 **lower()** 메소드를 불러 모두 소문자 로 처리한 후 비교해서 최댓값 알파벳 문자를 찾는다.


```python
# --- s = ['a', 'B', 'c', 'd', 'E']
max(s, key=str.lower)  # s 중 대소문자 구분하지 않고 최댓값을 찾아서 반환한다.
```

**sum**(***i***[, ***start***])

- 순회형 ***i***의 모든 객체를 더한 값을 반환한다.
- ***start*** 전달인자가 주어지지 않으면 기본값은 **0**이다.
- ***start*** 전달인자가 주어지면 ***start*** 전달인자와 순회형 ***i***의 객체들의 전체 합을 반환한다,
- ***i***에 문자열이 포함되어 있을 경우 **TypeError** 예외가 발생한다.


```python
x = [7, -5, 8, 3, 9]
```


```python
sum(x)     # x의 모든 값을 더한 값을 반환한다.          
```


```python
sum(x, 9)  # 9와 x의 모든 값을 더한 값을 반환한다.                    
```

### 정렬 함수

**reversed**(***seq***)
- 시퀀스형 ***seq***의 주어진 객체 순서를 역순으로 순회하는 순회자(iterator)를 반환한다.


```python
L = [7, -5, 8, 3, 9]
```


```python
reversed(L)
```


```python
type(reversed(L))  # reversed()가 반환한 객체의 자료형을 확인한다.                          
```


```python
list(reversed(L))  # reversed()가 반환한 객체를 리스트로 형변환한다.
```

**sorted**(***i, key=None, reverse=False***)
- 순회형 ***i***의 객체를 정렬하는 방식의 순서로 바꾼 후 **리스트**로 반환한다.
- ***key*** 전달인자를 사용하면 DSU(Decorate, Sort, Undecorated) 정렬이 가능하다.
- ***reverse*** 전달인자가 참(**True**)이면 정렬이 역순으로 이루어진다.

**sorted()** 함수의 기본 정렬 방식은 오름차순이다.


```python
L = [7, -5, 8, 3, 9]
```


```python
sorted(L)                         # 오름차순으로 정렬한다.
```


```python
sorted(L, reverse=True)           # 내림차순으로 정렬한다.
```


```python
sorted(L, key=abs)                # 절댓값으로 해서 오름차순으로 정렬한다.
```


```python
sorted(L, key=abs, reverse=True)  # 절댓값으로 해서 내림차순으로 정렬한다.
```

### 순환문과 함께 사용하는 유용한 함수

다음 세 함수는 8장의 순환문에서 상세히 다룰 것이다.

**range**(***start, stop, step***)
- 정수 순회자를 반환한다.
- 한 개의 전달인자(***stop***)가 주어지면 순회자는 0부터 ***stop*** **- 1**까지의 정수를 반환한다.
- 두 개의 전달인자(***start, stop***)가 주어지면 순회자는 ***start***부터 ***stop*** **- 1**까지의 정수를 반환한다.
- 세 개의 전달인자(***start, stop, step***)가 주어지면 순회자는 ***start***부터 ***step***만큼의 간격을 두고  ***stop*** **- 1**까지의 정수를 반환한다.

**enumerate**(***i, start=0***)
- 보통 **for ... in** 순환문과 함께 사용하며 `(인덱스, 객체)`의 튜플 쌍으로 순회할 수 있는 열거형(enumerate) 객체를 반환한다.
- ***start*** 전달인자가 주어지지 않으면 기본값은 **0**이다.
- ***start*** 전달인자가 주어지면 ***start*** 전달인자부터 인덱스가 시작된다.

**zip**(***i1, ..., iN***)
- 순회자 ***i1, ... , iN***을 사용하여 튜플 순회자를 반환한다.

***
**THE END**